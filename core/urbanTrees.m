function simout  = urbanTrees(urbanLandscape, opts, C_air, C_road)
%URBANTREES Simulates an epidemic in an urban landscape using the
%Doob-Gillespie algorithm.
%
% Syntax:  simout  = urbanTrees(urbanLandscape, opts)
%
% Inputs:
%   urbanLandscape      - Urban landscape
%   opts                - Options and parameter values struct for the
%                         urban epidemic model.
%
% Outputs:
%   simout - Struct with the simulation results
%
% Example:
%   simout = urbanTrees(urbanLandscape, opts);
%   This example runs a simulation on the urban landscape using the parameter values in opts.
%
% Other m-files required: none
% Subfunctions: none
% MAT-files required: none
%
% See also: for theoretical background Richard Stutt, 2014, Large Scale Epidemiological
% Modelling of Invading Plant Pathogens, Pembroke College, University of Cambridge
%
% Author: Eleftherios Avramidis
% Email: el.avramidis@gmail.com
% Copyright: MIT License
% Date: 17/03/2017
% Version: 1.0

tic
%% 
% Remove populations in case when either of the park/backyard or road trees are not wanted.
% user input option allows user to run model without either park or road
% trees if set to 0 - does this by removing all park population or road
% population 
% urbanLandscape.parkpopulation: vector containing number of trees in each
% cell that is categorized as a park tree
% urbanLandscape.roadpopulation: vector containing number of trees in each
% road segment

if opts.parkbackyardTreesON==0
    urbanLandscape.parkpopulation = urbanLandscape.parkpopulation.*0;
end

if opts.roadsideTreesON==0
    urbanLandscape.roadpopulation = urbanLandscape.roadpopulation.*0;
end

%% Set city epidemic simulation parameters
% urbanLandscape.roads contains two columns of cells. First column cell
% gives the grid reference of the start and end points of the road segment
% [x_start, y_start, x_end, y_end], second column cell gives the indexes of 
% the road segments that are close to the given road segment. Generated by
%  adatPrepare\src_mat\generateRoadStruct.m

roadSegments=urbanLandscape.roads;
tSpan=opts.tSpan;                   % Time span to run the simulation
tInterval=opts.tInterval;           % Time interval to save state of the simulation

%% Dispersal kernel parameters
% fraction of inoculum that stays in source cell or road segment
p_air=opts.p_air;                 
p_road=opts.p_road;   

% transmission rate for windborne or road dispersal of inoculum
beta_air=opts.beta_air;
beta_road=opts.beta_road;

% rate of decay of dispersion kernel from source
alpha_air=opts.alpha_air;
alpha_road=opts.alpha_road;

% maximum possible extent of dispersal
d_max_air=opts.d_max_air;
d_max_road=opts.d_max_road;

% maximum length of a road segment
max_roadSegment_length=opts.max_roadSegment_length;

% distance between center of grid cells
cell_size = abs(urbanLandscape.gridcenters(1,2)-urbanLandscape.gridcenters(2,2));

% Calculation of normalising constant which is chosen such that the kernel can be
% interpreted as a probability by fixing the integral of the kernel over all space to be 1.
% uses the function normalise_kernels - if doing multiple runs on same
% landscape then more efficient to precalculate these normalisation values
% see: exampleModelCall.m
if C_air==0 || isempty(find(C_road(1)~=0))
    disp('Calculating normalisation values.')
%     tic
    [opts.C_air, opts.C_road]=normalise_kernels(urbanLandscape.G, p_air, p_road, alpha_air, alpha_road, d_max_air, d_max_road, cell_size, max_roadSegment_length);
%     toc
    C_air=opts.C_air;
    C_road=opts.C_road;
    save('C_air.mat','C_air')
    save('C_road.mat','C_road')
else
    disp('Using precalculated normalisation values.')
    opts.C_air=C_air;
    opts.C_road=C_road;
end
%%
% Location of infected trees at time 0: can choose to start in a cell
% and/or a road segment - set as input to urbanTrees functions in exampleModelCall.m
startRoadSegment=opts.startRoadSegment;         % Start road of the epidemic
startCell=opts.startCell;                       % Start tile of the epidemic
%% Helper parameters used within function
% Time parameters
t=0;                        % Initial time at start of simulation
tp=0;                       % Time variable used for output
outidx=1;                   % Output index. Used to stored in output struct.

%% Setup random number generator
randomseedinfo=rng('shuffle', 'twister');

%% Calculate approximate grid ref of where epidemic starts if starts on a road segment
% calculated as half way along road segment (assuming linear)
% not used anywhere else in this function just output to simout. 
if(startRoadSegment>0)
    start_position=[(sum(roadSegments{startRoadSegment,1}(1:2))/2), (sum(roadSegments{startRoadSegment,1}(3:4))/2)];
else
    start_position=0;
end

%% Tree population setup

% Create empty vector to keep a record of number of trees in each road segment
roadpopulation=zeros(length(roadSegments),1); % pre-allocate space for computational efficiency
% Add number of trees for each road from data
roadpopulation=roadpopulation+urbanLandscape.roadpopulation;

% Park level tree population setup
parkpopulation=zeros(size(urbanLandscape.gridcenters,1),1); % pre-allocate space for computational efficiency
% add number of trees in each cell (not on road) to park population
parkpopulation=parkpopulation+urbanLandscape.parkpopulation;

%% Gillespie algorithm data structures

%% road population of trees Spr, Ipr (dummy variable Snr and Inr)
% Set up variables to contain the number of susceptible (Spr) and infected
% trees (Ipr)
% in each road segment (note model not currently extended to include a removed/recovered class or exposed class so only state change is S to I)
Spr=roadpopulation;                        % Set initial values for number of susceptible individuals on each road segment
Ipr=zeros(length(roadSegments),1);         % Set number of infected trees on each road to zero

% if the disease starts on a road segment, infect one tree in that road
% segment
if(startRoadSegment>0)
    Spr(startRoadSegment)=roadpopulation(startRoadSegment)-1;
    Ipr(startRoadSegment)=1;
end

% create two variables Snr and Inr which are used in the loop to store
% number of susceptible and infected trees prior to updating Snr and Inr
Snr=Spr;
Inr=Ipr;

% create variable and updating variable which will contain the calculated force of infection
% on each road segment
Rpr=zeros(length(roadSegments),1);         % Rates of infection for each road.
Rnr= Rpr;

% create variable which stores length of each road segment
Ds=urbanLandscape.roads_length;
% count the number of road segments (length gives size of largest array dimension - in this case the number of rows)
numRoadSegments=length(roadSegments);

%%
% localRoadsMap created by genLocalRoadsMap.m which is called by 
%...\urbanEpidemicModel\dataPrepare\urbanLandscapeGeneration.m
% found at ...urbanEpidemicModel\dataPrepare\src_mat\genLocalRoadsMap.m
% inputs: genLocalRoadsMap(urban_data, dmax)
% consists of a cell array in which all pairs of roads within the maximum road dispersal distance (dmaxroads) 
% of one another are listed
% road in the road_data.roads cell matrix is stored.
localRoadsMap=urbanLandscape.localRoadsMap;     

%% Park (cell) population of trees Spg, Ipg (dummy variables Sng, Ing)
% Grid level variables
Spg=parkpopulation;                                 % Set initial values for susceptible individuals for each road.
Ipg=zeros(length(urbanLandscape.gridcenters),1);    % Set initial values for infected individuals for each road.

% if the disease starts in parkland in a cell, infect one tree in the
% parkland part of the cell
if(startCell>0)
    Spg(startCell)=parkpopulation(startCell)-1;
    Ipg(startCell)=1;
end
Sng=Spg;
Ing=Ipg;

% create variable and updating variable which will contain the calculated force of infection
% on each cell (non-road part)
Rpg=zeros(length(urbanLandscape.gridcenters),1);         % Rates of infection for each road.
Rng= Rpg;

%% Simulation output data structure
simout = setup_output_struct(roadpopulation,parkpopulation,...
    randomseedinfo,roadSegments,start_position,startRoadSegment,startCell);

%% For cells which contain more than one road need to calculate the proportion of the total road area in the cell occupied by each road
% it is difficult to do precisely as roads overlap so this is an
% approximation whereby calculate the total length of road within a cell by
% adding up the length of all road segments in the cell and then calculate
% the fraction of the total road length contributed by each road segment
% Assume that if a cell contains one or more roads then the total area of
% the cell occupied by roads is 50% of the area of the cell regardless of
% total road length. This is because trying to compensate for overlapping
% roads etc is too complex at this scale (although could be refined using
% gis software - in which case would need to refine calculation of urbanLandscape.ppArea)

% pre-allocate storage to vectors used in loop by making vectors of zeros
% of length number of road segments.
road_cell_idx=zeros(numRoadSegments,1);
area_ratio_roads_cell=zeros(numRoadSegments,1);
cell_road_area=zeros(numRoadSegments,1);
cell_roads_area=zeros(numRoadSegments,1);
area_ratio_road_roads=zeros(numRoadSegments,1);
scaled_road_area=zeros(numRoadSegments,1);

% this is the road width (total width) applied in distinguishing between road and park
% trees (in meters) - need to modify if choose a different width when
% manipulating data.
RoadWidth = 40; %(20 meters either side of centerline of road)

for i=1:numRoadSegments
    % Find the cell the road populates
    road_cell_idx(i)=urbanLandscape.cellsonroad(i);
    % get all the roads that are in the same cell as road i
    cell_roads_idxs=find(urbanLandscape.cellsonroad==road_cell_idx(i));
    % calculate area of road i
    cell_road_area(i)=RoadWidth.*urbanLandscape.roads_length(i);
    % calculate area of all roads in each cell (ignoring overlap between
    % roads)
    cell_roads_area(i)=sum(RoadWidth.*urbanLandscape.roads_length(cell_roads_idxs));
    % calculate the proportion of road area in cell that is taken by a given road
    area_ratio_road_roads(i) = cell_road_area(i)./cell_roads_area(i);
    % assume cells that have roads in the roads occupy ppArea of the cell
    % (for simplicity we have assumed that if a cell contains roads then
    % they take up 50% of the cell area
    scaled_road_area(i) = area_ratio_road_roads(i)*urbanLandscape.ppArea(road_cell_idx(i));
end
% scaled road length
lambda_road = urbanLandscape.roads_length./max_roadSegment_length;
%% Calculate initial rates of infection on the road segments

% loop through all road segments in the study area
for i=1:numRoadSegments
    % Self infection
    Rpr(i)=0; %clears variable
    K=p_road; % assume fixed proportion of inoculum stay on source road
    % infection pressure on road segment from infectious trees within the
    % road segment. 
    % Rpr(i)=Rpr(i)+beta_road*Ipr(i)*K*scaled_road_area(i); % infection rate on to road i by trees on road i scaled by patch size
    
    Rpr(i)=Rpr(i)+beta_road*Ipr(i)*K*lambda_road(i); % infection rate on to road i by trees on road i scaled by road length
    % Find the closest roads to the i road segment - already recorded and
    % calculated in localRoadsMap (see earlier section in code)
    closeroads=localRoadsMap{i};
    % Infection by other road segments to the i road segment - infection on
    % the road network
    
    % this loop goes through the roads close to the current road i
    for jj=1:size(closeroads,1)
        j=closeroads(jj,1);
        
        % check whether the current 'close road' is in fact the road itself
        % - if so go back to start of this inner for loop and select the
        % next close road segment
        if i==j
            % Self infection pressure already calculated so skip to 
            % next value in for loop
            continue;
        end
        
        % if the close road has infected trees on it then work out the
        % distance between the center of road i and the center of close road j
        % if the distance is less than the maximum dispersal distance work
        % out the fraction of inoculum from road j which lands on road i.
        % C_road(j) is a precalculated scaling factor calculated in example model call from C_road=normalise_road_kernel(p_road, alpha_road, d_max_road, G, max_roadSegment_length);
        % which makes sure that all exactly 100% of inoculum from roads is dispersed
        % along roads
        if Ipr(j)>0 
            D = closeroads(jj,2); % precalculated distance from road j to road i d_ij
            if D<=d_max_road
                K=C_road(j)*exp(-alpha_road*D);
            else
                
                K=0;
            end
            %Rpr(i)=Rpr(i)+beta_road*Ipr(j)*K*scaled_road_area(i); % scaled
            %by patch size
            Rpr(i)=Rpr(i)+beta_road*Ipr(j)*K*lambda_road(i); % scaled by road length
        end
    end
    
    % Infection by other road segments to the i road segment - infection by air
    for j=1:numRoadSegments        
        if Ipr(j)>0
            % Find the cell the road populates
            road_j_cell_idx=road_cell_idx(j);

            if road_cell_idx(i) == road_j_cell_idx
                K = p_air;
            else
                % pythogoras theorem a^2+b^2 = c^2 therefore euclidean
                % distance is c = sqrt(a^2+b^2)
                D = (urbanLandscape.gridcenters(road_cell_idx(i),1)-urbanLandscape.gridcenters(road_j_cell_idx,1)).^2; %a^2
                D = D + (urbanLandscape.gridcenters(road_cell_idx(i),2)-urbanLandscape.gridcenters(road_j_cell_idx,2)).^2; %a^2+b^2
                D = sqrt(D); % sqrt(a^2+b^2)

                if D<=d_max_road
                    K=C_air*exp(-alpha_air*D);
                else
                    K=0;
                end
            end
            Rpr(i)=Rpr(i)+beta_road*Ipr(j)*K*scaled_road_area(i);
        end
    end
    
    % Infection by cells to the i road segment - infection by air
    for j=1:size(urbanLandscape.gridcenters,1)
        if (Ipg(j)>0)
            % Find the cell that the road segment is in
            if j==road_cell_idx(i)
                K=p_air;
            else
                D = (urbanLandscape.gridcenters(road_cell_idx(i),1)-urbanLandscape.gridcenters(j,1)).^2;
                D = D + (urbanLandscape.gridcenters(road_cell_idx(i),2)-urbanLandscape.gridcenters(j,2)).^2;
                D = sqrt(D);
                
                if D<=d_max_air
                    K=C_air*exp(-alpha_air*D);
                else
                    K=0;
                end
            end
            Rpr(i)=Rpr(i)+beta_air*Ipg(j)*K*scaled_road_area(i);
        end
    end
end
% multiply infection pressure by number of susceptibles to get infection
% rate
Rpr=Rpr.*Spr;
% save('Rpr.mat','Rpr')

%% Calculate initial rates of infection on the cells
for i=1:size(urbanLandscape.gridcenters,1)
    
    % Self infection
    Rpg(i)=0;
    K=p_air;
    Rpg(i)=Rpg(i)+beta_air*Ipg(i)*K*urbanLandscape.ppArea(i); %/(cell_size*cell_size);
    
    % Infection by other cells to the i cell
    for j=1:size(urbanLandscape.gridcenters,1)
        if i==j
            continue;
        end
        if (Ipg(j)>0)
            D = (urbanLandscape.gridcenters(i,1)-urbanLandscape.gridcenters(j,1)).^2;
            D = D + (urbanLandscape.gridcenters(i,2)-urbanLandscape.gridcenters(j,2)).^2;
            D = sqrt(D);
            
            if D<=d_max_air
                K=C_air*exp(-alpha_air*D);
            else
                K=0;
            end
            
            Rpg(i)=Rpg(i)+beta_air*Ipg(j)*K*urbanLandscape.ppArea(i); %/(cell_size*cell_size);
        end
    end
    
    % Infection by road segments to the i cell by air
    for j=1:numRoadSegments
        % check to see if road segment j contains infected trees 
        % Ipr(j) = number of infected trees on road segment j
        if (Ipr(j)>0)
            % Find the cell the road populates
            road_j_cell_idx=road_cell_idx(j);
            % if the road segment is in the current cell (this for loop is
            % part of larger loop) then the proportion of the infectious
            % agent dropped in the cell due to aerial dispersal is p_air
            
            if i==road_j_cell_idx
                K=p_air;
            % otherwise use pythogoras theorem to calculate the distance of the road segment from the
            % current grid cell
            else
                D = (urbanLandscape.gridcenters(i,1)-urbanLandscape.gridcenters(road_j_cell_idx,1)).^2;
                D = D + (urbanLandscape.gridcenters(i,2)-urbanLandscape.gridcenters(road_j_cell_idx,2)).^2;
                D = sqrt(D);
                % if it is less than the cut of distance then apply
                % dispersion kernel to work out proportion of inoculum from
                % road segment that would fall on cell
                if D<=d_max_air
                    K=C_air*exp(-alpha_air*D);
                else
                    K=0;
                end
            end
            % add calculated rate of infection from road segment j to rolling sum of rate of infection from road to garden patch i
            Rpg(i)=Rpg(i)+beta_air*Ipr(j)*K*urbanLandscape.ppArea(i); %/(cell_size*cell_size);
        end
    end
end
% multiply infection pressure by number of susceptibles to get infection
% rate
Rpg=Rpg.*Spg;
% save('Rpg.mat','Rpg')

simout.toutput=0;
simout.Ioutput=Inr;
simout.Ioutputg=Ing;
simout.Soutput=Snr;
simout.Soutputg = Sng;
outidx=outidx+1;

%% Run the simulation
while t<=tSpan
%     t
    % Calculate the time interval to the next event
    T3=sum(Rpr) + sum(Rpg);
    if T3==0 & t == 0 % CRW: added condition t==0 so distinguishes between nothing ever happening and nothing else happened after some initial infection
        simout.nothinghappened=-1;
        disp('Nothing happened - stop simulation.')
        break; 
    elseif T3==0 & t > 0 
        simout.nothinghappened=-2;
        disp('Nothing happened - stop simulation.')
        break; 
    end
    
    y3=-log(rand)/T3;
    if t+y3>=tSpan
        break;
    else
        t=t+y3;      % Update the simulation timer
    end
    
    tp=tp+y3;   % Update the time interval for the output
    
    if tp>=tInterval
        for i=1:floor(tp/tInterval)
            % Save results to output data structure
            simout.toutput=[simout.toutput; (outidx-1)*tInterval];
            
            % Store the new values for the latest timestamp
            if i==floor(tp/tInterval)
                simout.Ioutput(:,outidx)=Inr;
                simout.Ioutputg(:,outidx)=Ing;
                simout.Soutput(:,outidx)=Snr;
                simout.Soutputg(:,outidx)=Sng;
            else
                simout.Ioutput(:,outidx)=Ipr;
                simout.Ioutputg(:,outidx)=Ipg;
                simout.Soutput(:,outidx)=Snr;
                simout.Soutputg(:,outidx)=Sng;
            end
            outidx=outidx+1;
        end
        tp=0;   % reset the timer for the output
    end
    
    % Choose the cell or road segment that the event happened
    idx=roulettewheelselection([Rpr; Rpg]);
    if (idx==-1)
        disp('No valid selection.')
        break;
    end
    if (idx<=length(Rpr))
        eventhappened=1;
    else
        eventhappened=2;
        idx=idx-length(Rpr);
    end
    
    % The event happened at a road segment
    if (eventhappened==1)
        % decrease number of susceptible trees by 1 in affected patch
        
        Snr(idx)=Spr(idx)-1; % subscript decoding: n = new; p = previous
        if Snr(idx)<0
            Snr(idx)=0;
            disp('Error tried to infect already fully infected road segment!')
            break;
        end
        if Snr(idx)>roadpopulation(idx)
            Snr(idx)=roadpopulation(idx);
            disp('Error susceptibles are more than the population of the road segment!')
            break;
        end
        % increase number of infected trees by 1 in affected patch
        Inr(idx)=Ipr(idx)+1;
        
        if Inr(idx)<0
            Inr(idx)=0;
            disp('Error number of infected hosts is negative in road segment!')
            break;
        end
        if Inr(idx)>roadpopulation(idx)
            Inr(idx)=roadpopulation(idx);
            disp('Error infected are more than the population of the road segment!')
            break;
        end
        
        K=p_road;
        if Snr(idx)>0
            % Update infection rate to itself by road
            % Rnr(idx)=Rpr(idx)-(Rpr(idx)/Spr(idx))+Snr(idx)*beta_road*K*scaled_road_area(idx); % scaled by patch size
            Rnr(idx)=Rpr(idx)-(Rpr(idx)/Spr(idx))+Snr(idx)*beta_road*K*lambda_road(i); % scaled by road length
            if Rnr(idx)<0
                pause
            end
        else
            Rnr(idx)=0;
        end

        closeroads=localRoadsMap{idx};
        % Update infection rate of other road segments
        for jj=1:size(closeroads,1)
            j=closeroads(jj,1);
            if idx==j
                continue;
            end
            
            if Spr(j)>0
            D = closeroads(jj,2); % precalculated distance from road j to road i
                if D<=d_max_road
                    K=C_road(idx)*exp(-alpha_road*D);
                else
                    K=0;
                end

               % Rnr(j)=Rpr(j)+beta_road*K*Spr(j)*scaled_road_area(j); %
               % scaled by patch size
               Rnr(j)=Rpr(j)+beta_road*K*Spr(j)*lambda_road(i); %scaled by road length
            end
        end
        
        % Infection to other road segments by the idx road segment - infection by air
        for j=1:numRoadSegments            
            % Find the cell the road populates
            road_j_cell_idx=urbanLandscape.cellsonroad(j);
            
            if road_cell_idx(idx) == road_j_cell_idx
                K = p_air;
                
                % Update infection rate of event cell
                if (Snr(j)>0)
                    %Rnr(j)=Rnr(j) + Rpr(j)-(Rpr(j)/Spr(j))+Snr(j)*beta_air*K*scaled_road_area(j);
                    % have already discounted previous infection rate when
                    % did roadside infection.
                    Rnr(j)=Rnr(j) + Snr(j)*beta_air*K*scaled_road_area(j);
                    if Rnr(j)<0
                        pause
                    end
                else
                    Rnr(j)=0;
                end
            else
                if (Snr(j)>0)
                    D = (urbanLandscape.gridcenters(road_cell_idx(idx),1)-urbanLandscape.gridcenters(road_j_cell_idx,1)).^2;
                    D = D + (urbanLandscape.gridcenters(road_cell_idx(idx),2)-urbanLandscape.gridcenters(road_j_cell_idx,2)).^2;
                    D = sqrt(D);

                    if D<=d_max_air
                        K=C_air*exp(-alpha_air*D);
                    else
                        K=0;
                    end
                    Rnr(j)=Rnr(j)+beta_air*K*Spr(j)*scaled_road_area(j);
                    if Rnr(j)<0
                        pause
                    end  
                else
                    Rnr(j)=0;
                end
            end
        end
        
        % Update infection rate of cells by air
        for j=1:size(urbanLandscape.gridcenters,1)
            if (Sng(j)>0)
                if road_cell_idx(idx)==j
                    K=p_air;
                else
                    D = (urbanLandscape.gridcenters(road_cell_idx(idx),1)-urbanLandscape.gridcenters(j,1)).^2;
                    D = D + (urbanLandscape.gridcenters(road_cell_idx(idx),2)-urbanLandscape.gridcenters(j,2)).^2;
                    D = sqrt(D);
                    
                    if D<=d_max_air
                        K=C_air*exp(-alpha_air*D);
                    else
                        K=0;
                    end
                end
                Rng(j)=Rpg(j)+beta_air*K*Spg(j)*urbanLandscape.ppArea(j);%/(cell_size*cell_size);
            else
                Rng(j)=0;
            end
        end
    end
    
    % The event happened at a cell
    if (eventhappened==2)
        Sng(idx)=Spg(idx)-1;
        if Sng(idx)<0
            Sng(idx)=0;
            disp('Error tried to infect already fully infected cell!')
            break;
        end
        if Sng(idx)>parkpopulation(idx)
            Sng(idx)=parkpopulation(idx);
            disp('Error susceptibles are more than the population of the cell!')
            break;
        end
        Ing(idx)=Ipg(idx)+1;
        if Ing(idx)<0
            Ing(idx)=0;
            disp('Error number of infected hosts is negative in cell!')
            break;
        end
        if Ing(idx)>parkpopulation(idx)
            Ing(idx)=parkpopulation(idx);
            disp('Error infected are more than the population of the cell!')
            break;
        end
        
%         Rng = Rng.*0;
        
        K=p_air;
        % Update infection rate of event cell
        if (Sng(idx)>0)
            Rng(idx)=Rpg(idx)-(Rpg(idx)/Spg(idx))+Sng(idx)*beta_air*K*urbanLandscape.ppArea(idx);%/(cell_size*cell_size);
            if Rng(idx)<0
                pause
            end
        else
            Rng(idx)=0;
        end
        
        % Update infection rate of other cells
        for j=1:size(urbanLandscape.gridcenters,1)
            if (idx==j)
                continue;
            end
            if (Spg(j)>0)
                D = (urbanLandscape.gridcenters(idx,1)-urbanLandscape.gridcenters(j,1)).^2;
                D = D + (urbanLandscape.gridcenters(idx,2)-urbanLandscape.gridcenters(j,2)).^2;
                D = sqrt(D);
                
                if D<=d_max_air
                    K=C_air*exp(-alpha_air*D);
                else
                    K=0;
                end
                
                Rng(j)=Rpg(j)+beta_air*K*Spg(j)*urbanLandscape.ppArea(j); %/(cell_size*cell_size);
            else
                Rng(j)=0;
            end
        end
        
        % Update infection rate of road segments by air
        for j=1:numRoadSegments
            if (Snr(j)>0)
                % Find the cell the road populates
                road_j_cell_idx=urbanLandscape.cellsonroad(j);
                
                if idx==road_j_cell_idx
                    K=p_air;
                else
                    D = (urbanLandscape.gridcenters(idx,1)-urbanLandscape.gridcenters(road_j_cell_idx,1)).^2;
                    D = D + (urbanLandscape.gridcenters(idx,2)-urbanLandscape.gridcenters(road_j_cell_idx,2)).^2;
                    D = sqrt(D);
                    
                    if D<=d_max_air
                        K=C_air*exp(-alpha_air*D);
                    else
                        K=0;
                    end
                end
                
                Rnr(j)=Rpr(j)+beta_air*K*Spr(j)*scaled_road_area(j);
                if Rnr(j)<0
                    pause
                end
            end
        end
    end
    
    Rpr=Rnr;
    Spr=Snr;
    Ipr=Inr;
    
    Rpg=Rng;
    Spg=Sng;
    Ipg=Ing;
    
    %     if (sum(Rpr)==0 && sum(Rpg)==0)
    %         disp(['All infected or cannot infect more - ending simulation - t=' num2str(t)]);
    %         break;
    %     end
end

for i=1:(tSpan/tInterval - length(simout.toutput))+1
    % Save results to output data structure
    simout.toutput=[simout.toutput; (outidx-1)*tInterval];
    
    % Store the new values for the latest timestamp
    simout.Ioutput(:,outidx)=Inr;
    simout.Ioutputg(:,outidx)=Ing;
    simout.Soutput(:,outidx)=Snr;
    simout.Soutputg(:,outidx)=Sng;
    outidx=outidx+1;
end
toc